import { BaseResult, JumpTime } from "../types/Studies";
import Database from "@tauri-apps/plugin-sql";
import { Athlete } from "../types/Athletes";

// Helper function to insert base_result
const saveBaseResult = async (
  db: Database,
  athleteId: string,
  result: BaseResult,
  date: Date
): Promise<number> => {
  const insertResult = await db.execute(
    `INSERT INTO base_result (athlete_id, takeoff_foot, sensitivity, created_at)
       VALUES (?, ?, ?, ?)`,
    [
      athleteId,
      result.takeoffFoot,
      result.sensitivity,
      date.toISOString(), // Use ISO string for datetime
    ]
  );
  return insertResult.lastInsertId;
};

// Helper function to insert jump_time records
const saveJumpTimes = async (
  db: Database,
  baseResultId: number,
  times: JumpTime[]
): Promise<void> => {
  if (!times || times.length === 0) {
    return;
  }

  // Prepare placeholders and values for bulk insert
  const placeholders = times
    .map((_, index) => "(?, ?, ?, ?, ?, ?, ?)")
    .join(", ");
  const values: unknown[] = []; // Use unknown[] instead of SqlValue[]
  times.forEach((time, index) => {
    values.push(
      baseResultId,
      index,
      time.time,
      time.deleted ? new Date().toISOString() : null, // Set deleted_at if deleted
      time.floorTime ?? null,
      time.stiffness ?? null,
      time.performance ?? null
    );
  });

  await db.execute(
    `INSERT INTO jump_time (base_result_id, "index", time, deleted_at, floor_time, stiffness, performance)
       VALUES ${placeholders}`,
    values
  );
};

// Function to save athlete data and studies
export const saveAthlete = async (athlete: Athlete): Promise<void> => {
  try {
    const db = await (Database as any).load("sqlite:ergolab.db");

    // Use transaction for atomicity
    await db.execute("BEGIN TRANSACTION");

    try {
      // 1. Insert or Update Athlete info
      // Assuming athlete.id might be pre-existing or generated elsewhere.
      // If the ID is always generated by the DB on insert, adjust logic.
      // For simplicity, we'll use INSERT OR REPLACE based on ID.
      await db.execute(
        `INSERT OR REPLACE INTO athlete (id, name, birth_date, country, state, gender, height, height_unit, weight, weight_unit, discipline, category, institution, comments)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          athlete.id, // Make sure athlete.id is provided
          athlete.name,
          athlete.birthDate?.toISOString().split("T")[0], // Format as YYYY-MM-DD
          athlete.country,
          athlete.state,
          athlete.gender,
          athlete.height,
          athlete.heightUnit,
          athlete.weight,
          athlete.weightUnit,
          athlete.discipline,
          athlete.category,
          athlete.institution,
          athlete.comments,
        ]
      );

      // 2. Delete existing studies for this athlete to avoid duplicates
      // This is a simple strategy. More complex update logic could be implemented.
      const existingBaseResults = await db.select(
        "SELECT id FROM base_result WHERE athlete_id = ?",
        [athlete.id]
      );
      if (existingBaseResults.length > 0) {
        const baseResultIds = existingBaseResults.map((r: any) => r.id); // Add :any type assertion or infer type
        const placeholders = baseResultIds.map(() => "?").join(",");
        // Cascade deletes should handle related tables if set up, otherwise delete manually
        await db.execute(
          `DELETE FROM jump_time WHERE base_result_id IN (${placeholders})`,
          baseResultIds
        );
        await db.execute(
          `DELETE FROM basic_result WHERE base_result_id IN (${placeholders})`,
          baseResultIds
        );
        await db.execute(
          `DELETE FROM drop_jump_result WHERE base_result_id IN (${placeholders})`,
          baseResultIds
        );
        await db.execute(
          `DELETE FROM multiple_jumps_result WHERE base_result_id IN (${placeholders})`,
          baseResultIds
        );
        // Need to handle deletion related to bosco and multiple_drop_jump separately if they don't cascade from base_result
        await db.execute(`DELETE FROM bosco_result WHERE athlete_id = ?`, [
          athlete.id,
        ]);
        await db.execute(
          `DELETE FROM multiple_drop_jump_result WHERE athlete_id = ?`,
          [athlete.id]
        );
        await db.execute(
          `DELETE FROM base_result WHERE id IN (${placeholders})`,
          baseResultIds
        );
      }

      // 3. Iterate and insert completed studies
      for (const completedStudy of athlete.completedStudies) {
        const studyResult = completedStudy.results;
        const studyDate = completedStudy.date;

        switch (studyResult.type) {
          case "cmj":
          case "squatJump":
          case "abalakov":
          case "custom": {
            const baseResultId = await saveBaseResult(
              db,
              athlete.id,
              studyResult,
              new Date(studyDate)
            );
            await db.execute(
              `INSERT INTO basic_result (type, load, loadunit, base_result_id)
                 VALUES (?, ?, ?, ?)`,
              [
                studyResult.type,
                studyResult.load,
                studyResult.loadUnit,
                baseResultId,
              ]
            );
            await saveJumpTimes(db, baseResultId, studyResult.times);
            break;
          }
          case "multipleJumps": {
            const baseResultId = await saveBaseResult(
              db,
              athlete.id,
              studyResult,
              new Date(studyDate)
            );
            await db.execute(
              `INSERT INTO multiple_jumps_result (criteria, criteria_value, base_result_id)
                 VALUES (?, ?, ?)`,
              [studyResult.criteria, studyResult.criteriaValue, baseResultId]
            );
            await saveJumpTimes(db, baseResultId, studyResult.times);
            break;
          }
          case "multipleDropJump": {
            // Insert the parent record
            const mdjrInsertResult = await db.execute(
              `INSERT INTO multiple_drop_jump_result (athlete_id, height_unit, takeoff_foot, best_height, created_at)
                   VALUES (?, ?, ?, ?, ?)`,
              [
                athlete.id,
                studyResult.heightUnit,
                studyResult.takeoffFoot,
                studyResult.bestHeight,
                new Date(studyDate).toISOString(),
              ]
            );
            const multipleDropJumpResultId = mdjrInsertResult.lastInsertId; // Needed if drop_jump_result needs to link back

            // Insert each individual drop jump within the multiple drop jump
            for (const dropJump of studyResult.dropJumps) {
              // Each drop jump needs its own base result and jump times
              const baseResultId = await saveBaseResult(
                db,
                athlete.id,
                dropJump,
                new Date(studyDate)
              );
              await db.execute(
                `INSERT INTO drop_jump_result (height, stiffness, base_result_id) -- Add multiple_drop_jump_result_id if schema supports it
                     VALUES (?, ?, ?, ?)`, // Add placeholder for multipleDropJumpResultId if needed
                [
                  dropJump.height,
                  dropJump.stiffness,
                  baseResultId,
                  multipleDropJumpResultId,
                ]
              );
              await saveJumpTimes(db, baseResultId, dropJump.times);
            }
            break;
          }
          case "bosco": {
            // Insert parent bosco_result
            const boscoInsertResult = await db.execute(
              `INSERT INTO bosco_result (athlete_id, created_at) VALUES (?, ?)`,
              [athlete.id, new Date(studyDate).toISOString()]
            );
            const boscoResultId = boscoInsertResult.lastInsertId;

            // Insert CMJ component if present
            if (studyResult.cmj && studyResult.cmj.times.length > 0) {
              const baseResultId = await saveBaseResult(
                db,
                athlete.id,
                studyResult.cmj,
                new Date(studyDate)
              );
              await db.execute(
                `INSERT INTO basic_result (type, load, loadunit, base_result_id, bosco_result_id)
                       VALUES (?, ?, ?, ?, ?)`,
                [
                  "cmj",
                  studyResult.cmj.load,
                  studyResult.cmj.loadUnit,
                  baseResultId,
                  boscoResultId,
                ]
              );
              await saveJumpTimes(db, baseResultId, studyResult.cmj.times);
            }
            // Insert SquatJump component if present
            if (
              studyResult.squatJump &&
              studyResult.squatJump.times.length > 0
            ) {
              const baseResultId = await saveBaseResult(
                db,
                athlete.id,
                studyResult.squatJump,
                new Date(studyDate)
              );
              await db.execute(
                `INSERT INTO basic_result (type, load, loadunit, base_result_id, bosco_result_id)
                       VALUES (?, ?, ?, ?, ?)`,
                [
                  "squatJump",
                  studyResult.squatJump.load,
                  studyResult.squatJump.loadUnit,
                  baseResultId,
                  boscoResultId,
                ]
              );
              await saveJumpTimes(
                db,
                baseResultId,
                studyResult.squatJump.times
              );
            }
            // Insert Abalakov component if present
            if (studyResult.abalakov && studyResult.abalakov.times.length > 0) {
              const baseResultId = await saveBaseResult(
                db,
                athlete.id,
                studyResult.abalakov,
                new Date(studyDate)
              );
              await db.execute(
                `INSERT INTO basic_result (type, load, loadunit, base_result_id, bosco_result_id)
                       VALUES (?, ?, ?, ?, ?)`,
                [
                  "abalakov",
                  studyResult.abalakov.load,
                  studyResult.abalakov.loadUnit,
                  baseResultId,
                  boscoResultId,
                ]
              );
              await saveJumpTimes(db, baseResultId, studyResult.abalakov.times);
            }
            break;
          }
          default:
            // Handle unknown study type or throw error
            console.warn(
              "Unknown study type encountered:",
              (studyResult as any).type
            );
        }
      }

      // Commit transaction
      await db.execute("COMMIT");
    } catch (innerError) {
      // Rollback transaction on error
      console.error("Error during save, rolling back transaction:", innerError);
      await db.execute("ROLLBACK");
      throw innerError; // Re-throw error after rollback
    }
  } catch (error) {
    console.error("Failed to save athlete:", error);
    // Optionally, handle specific errors or re-throw
  }
};
